# Service Mesh

Организует межсервисное взаимодействие между сервисами.

**Проблема**: если мы используем микросервисную архитектуру, нам нужно организовать межсервисное взаимодействие.

Service mesh — это слой инфраструктуры поверх Kubernetes (или другой платформы), который управляет сетевыми взаимодействиями между микросервисами.

**Основная идея**: вынести в инфраструктуру ряд функциональности, чтобы не приходилось решать эти задачи в коде.

Выделенный **инфраструктурный уровень**, который совершенствует коммуникацию между сервисами в k8s и добавляет в сеть функции между сервисами:

- Управление трафиком
  - Роутинг трафика на основе правил маршуризации 
  - Балансировка трафика
  - Серкет-брейкеры (выключают плохо работающий/сбоящий сервис из работы), ретраи, рейтлимиты (защита от DDoS)
- Безопасность
  - Добавление TLS
- Наблюдаемость 
  - Хелс-чеки
  - Метрики
  - Трассировка

---

### Подход

Поставить перед каждым сервисом по прокси-серверу (обычно это **Envoy**),  
который перехватывает весь входящий и исходящий трафик и позволяет более гибко управлять трафиком и безопасностью соединений между сервисами.

Каждый под это по сути своя локальная сеть — **Envoy** получает управление над этой локальной сетью.

Сервис-меш динамически конфигурирует эти прокси-серверы.

Все изменения в сетевой логике являются **прозрачными** для сервисов.

Почему **Envoy**, а не Nginx? Ключевая причина - потому что Envoy позволяет динамически обновлять конфигурацию.

### Istio

**Istio** — одна из самых популярных реализаций сервис-меш.

Istio добавляет свои шлюзы (gateway) на границы кластера для управления входящим и исходящим трафиком. В Istio ingress gateway управляет входящим трафиком в mesh, а egress gateway контролирует исходящий трафик наружу.

Istio "из коробки" встраивается в классический стек мониторинга. Без изменений в приложении. Метрики и трейсы появляются, как только трафик идёт через sidecar/gateway. Есть готовые дашборды в Grafana, можно подключить Kiali (граф сервисов), Jaeger/Zipkin (трейсинг) и тп

---

### Архитектура

- **Data-plane** — множество прокси-серверов, которые располагаются перед контейнерами и позволяют управлять трафиком.
- **Control-plane** — настройка правил через объекты Istio и динамическое конфигурирование Envoy-сайдкаров.

Администратор сети может декларативно конфигурировать сервис меш через апи истио

Service Mesh работает на L7 (т.е. понимает прикладные протоколы, может делать маршрутизацию, ретраи и т.д). Kube-proxy, который стоит на каждой ноде, работает на L4 (IP/port) и обеспечивает только базовый сервис-дискавери.

---

### Пять основных объектов Istio

**Gateway**
Определяет точку входа/выхода в mesh.  
Привязывается к ingress/egress-gateway (Envoy) и описывает, какие хосты/порты/протоколы принимает.  
Пример: «на шлюзе слушаем `myapp.com:443` по HTTPS».

---

**VirtualService**
Описывает правила маршрутизации: куда и как отправлять трафик.  
Пример: «все запросы на `/v1/*` → service-A, на `/v2/*` → service-B».

---

**DestinationRule**
Задаёт политику для трафика после маршрутизации.  
Например: балансировка (round-robin, least request), поднаборы (subsets) для канареек, TLS-политика.  
Пример: «все вызовы в service-A версии `v1` шифруем mTLS, балансируем по round-robin».

---

**ServiceEntry**
«Белый список» для доступа наружу из mesh.  
Пример: «разрешить доступ к `api.stripe.com:443`».

---

**Sidecar**
Определяет, какие хосты/сервисы доступны конкретному pod-sidecar’у.  
Можно ограничить зону видимости (чтобы sidecar не видел весь mesh, а только нужные сервисы).  
Пример: «этот pod видит только namespace `payments` и внешний `redis.example.com`».
