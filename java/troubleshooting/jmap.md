# jmap — выжимка (шпаргалка)

Коротко: **`jmap` — консольная утилита из JDK для диагностики памяти JVM**. Позволяет снять **heap dump**, посмотреть **гистограмму классов**, сводку по **куче/GC**. Полезна при поиске утечек и анализе аномального потребления памяти.

---

## Что умеет
- **Heap dump (HPROF)** — полный снимок объектов кучи для последующего анализа (Eclipse MAT, YourKit, VisualVM).
- **Class histogram** — число объектов и суммарный объём по типам.
- **Сводка по куче/GC** — размеры регионов/поколений, алгоритм GC, использовано/свободно, Metaspace и т. п.

> `jmap` подключается к живому JVM‑процессу через Attach API или работает по core‑дампу через Serviceability Agent.

---

## Быстрый старт (частые команды)

```bash
# Сводка по куче и GC
jmap -heap <PID>

# Гистограмма классов (все объекты)
jmap -histo <PID>

# Гистограмма только «живых» объектов (требует маркировки → STW-пауза)
jmap -histo:live <PID>

# Снять heap dump (бинарный HPROF)
jmap -dump:format=b,file=heap.hprof <PID>

# Снять только «живые» объекты (обычно вызывает STW-паузу на маркировку)
jmap -dump:live,format=b,file=heap.hprof <PID>
```

### Эквиваленты в `jcmd` (предпочтительно на новых JDK)
```bash
jcmd <PID> GC.heap_info
jcmd <PID> GC.class_histogram
jcmd <PID> GC.heap_dump filename=heap.hprof
```

> Для длительного сбора с низкой нагрузкой рассмотрите **JFR (Java Flight Recorder)**.

---

## Когда применять
- Подозрение на **утечку памяти** или «распухание» графа объектов.
- Неожиданный рост **Metaspace** / количества классов.
- Нужен быстрый ответ «кто занимает память сейчас».

---

## Влияние и риски
- **Паузы (STW)**: `-histo:live`/`-dump:live` запускают маркировку достижимости → возможны заметные стоп‑the‑world паузы.
- **Нагрузка**: сбор и запись дампа могут нагружать CPU/диск.
- **Размер файла**: `heap.hprof` ≈ объём живых данных в куче (гигабайты — норма). Проверьте свободное место и путь.
- **Права/контейнеры**: для attach требуется доступ к процессу (тот же пользователь/UID). В Docker/кластере может потребоваться
  дополнительные привилегии (например, `CAP_SYS_PTRACE`) и доступ к `/proc/<PID>` контейнера.
- **Версии JDK**: часть старых опций помечена как устаревшие — на новых версиях используйте `jcmd`/JFR.

---

## Рекомендации по эксплуатации
- В проде предпочитайте **не‑live** операции, либо выполняйте в **непик** и предупреждайте SRE/DevOps.
- Именуйте файлы по времени: `heap-$(date +%Y%m%d-%H%M%S).hprof`.
- Сжимайте дампы для хранения/передачи: `xz -T0 heap.hprof`.
- Для автоматического дампа при OOME:
  ```text
  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/heap.hprof
  ```
- Анализируйте в **Eclipse MAT**: смотрите *Leak Suspects*, *Dominator Tree*, *Top Consumers*; ищите удерживающие ссылки (retained size).

---

## Быстрый чек‑лист поиска утечки
1. Снимите `heap.hprof` (желательно в момент «пика»).  
2. Откройте в MAT → *Leak Suspects Report*.  
3. Изучите крупные доминаторы (бОльший **retained size**).  
4. Проверьте кэши/коллекции без ограничений, статические поля, слушатели/замыкания, пул потоков/заданий.  
5. Сопоставьте с кодом/метриками и исправьте удерживающие ссылки.

---

## Не путать с
- Профилировщиками CPU/alloc (async-profiler, YourKit в sampling/tracing) — `jmap` **не** профилирует, он **снимает снимки памяти**.
- Средствами логирования GC — они показывают поведение GC, но не структуру живых объектов.

---

### Мини‑шпаргалка команд
```
jmap -heap <PID>                 # сводка по куче/GC
jmap -histo <PID>                # гистограмма классов
jmap -histo:live <PID>           # только живые (STW)
jmap -dump:format=b,file=heap.hprof <PID>        # heap dump
jmap -dump:live,format=b,file=heap.hprof <PID>   # heap dump живых (STW)
# Аналоги в jcmd:
jcmd <PID> GC.heap_info
jcmd <PID> GC.class_histogram
jcmd <PID> GC.heap_dump filename=heap.hprof
```
